/*
  PROBLEM: LeetCode 81 - Search in Rotated Sorted Array II (with Duplicates)
  PATTERN: Binary Search (Modified with "Shaving")
  TIME COMPLEXITY: O(log N) on average, but O(N) worst case
  SPACE COMPLEXITY: O(1)

  STRATEGY
  1. Due to the array being rotated at one point, we split the array in half and search for sorted side.
  2. If sorted side, we check if target is in that half, search that half. Otherwise search other half
  3. We have to check for duplicates on the left and right. if found, we check for match, and move both.

  NOTES
  - Quite a few edge cases/things to watch out for. Need to be careful with how to round (Math.floor vs Math.round)
    and checking the bounds of the array (e.g. edges of the array, equality check < vs <=)
  
  https://leetcode.com/problems/search-in-rotated-sorted-array-ii/
*/

/**
 * @param {number[]} nums
 * @param {number} target
 * @return {boolean}
 */
var search = function(nums, target) {
    let left = 0;
    let right = nums.length - 1;
    // how to determine if it's left < right vs left <= right??
    while (left <= right) {
        const leftN = nums[left];
        const rightN = nums[right];
        const mid = Math.floor((right - left) / 2) + left;
        const midN = nums[mid];
        if (midN === target) return true;
        if (leftN === rightN) {
            if (leftN === target) {
                return true;
            }
            left++;
            right--;
            continue;
        }
        // right is sorted
        if (rightN > midN) {
            if (target > midN && target <= rightN) left = mid + 1;
            else right = mid - 1;
        } else {
            if (target >= leftN && target < midN) right = mid - 1;
            else left = mid + 1
        }
    }
    return false
};